# This Python file uses the following encoding: utf-8
"""autogenerated by genpy from vehicle_msgs/Camera_Lane.msg. Do not edit."""
import sys
python3 = True if sys.hexversion > 0x03000000 else False
import genpy
import struct

import vehicle_msgs.msg
import std_msgs.msg

class Camera_Lane(genpy.Message):
  _md5sum = "c5897b7b9f9cb0b914b0d2214c60af5a"
  _type = "vehicle_msgs/Camera_Lane"
  _has_header = True #flag to mark the presence of a Header object
  _full_text = """Header  header
int32 	messageID              #为每一个MSG设定唯一的标识码

FrameStamp localStamp
FrameStamp globalStamp
 
int32 l_numoflaneline
int32 l_lanelineid
float64 l_lanepositon
float64 l_lanecurvature
float64 l_lanecurvaturederivative
int32 l_lane_type
float64 l_heading_angle
int32  l_lane_mark_color
int32 l_laneQuality
int32 l_laneWidthMarking
int32 l_laneViewRangStart
int32 l_laneViewRangEnd
int32 l_laneCrossing
int32 l_lanePRED_DIST_BASED_EXTRAPOLATION
int32 l_lanePRED_OTHER_SIDE
int32 l_lanePRED_OVERRIDE
int32 l_lanePRED_OCCLUDED_LM_EXTRAPOLATION
int32 l_lanePRED_HEADWAY_ORIENTED
int32 l_lanePRED_SOURCE_DIVERGING_LANES
int32 l_lanePRED_SOURCE_GUARDRAIL_SHADOW
int32 l_lanePRED_SOURCE_HWE_SPAIN
int32 l_lanePRED_SOURCE_STD
int32 l_lanePRED_SOURCE_VRTL_MERGE
int32 l_laneTCL


int32 r_numoflaneline
int32 r_lanelineid
float64 r_lanepositon  
float64 r_lanecurvature  
float64 r_lanecurvaturederivative 
int32 r_lane_type
float64 r_heading_angle  
int32  r_lane_mark_color
int32 r_laneQuality
int32 r_laneWidthMarking
int32 r_laneViewRangStart
int32 r_laneViewRangEnd
int32 r_laneCrossing
int32 r_lanePRED_DIST_BASED_EXTRAPOLATION
int32 r_lanePRED_OTHER_SIDE
int32 r_lanePRED_OVERRIDE
int32 r_lanePRED_OCCLUDED_LM_EXTRAPOLATION
int32 r_lanePRED_HEADWAY_ORIENTED
int32 r_lanePRED_SOURCE_DIVERGING_LANES
int32 r_lanePRED_SOURCE_GUARDRAIL_SHADOW
int32 r_lanePRED_SOURCE_HWE_SPAIN
int32 r_lanePRED_SOURCE_STD
int32 r_lanePRED_SOURCE_VRTL_MERGE
int32 r_laneTCL


int32 next_l_laneViewRangStart
int32 next_l_laneViewRangEnd
int32 next_l_numoflaneline
int32 next_l_lanelineid
float64 next_l_lanepositon
float64  next_l_lanecurvature
float64 next_l_lanecurvaturederivative
int32 next_l_lane_type
float64 next_l_heading_angle
int32  next_l_lane_mark_color
int32 next_l_laneQuality
int32 next_l_laneWidthMarking

int32 next_r_laneViewRangStart
int32 next_r_laneViewRangEnd
int32 next_r_numoflaneline
int32 next_r_lanelineid
float64 next_r_lanepositon
float64 next_r_lanecurvature
float64 next_r_lanecurvaturederivative
int32 next_r_lane_type
float64 next_r_heading_angle
int32  next_r_lane_mark_color
int32 next_r_laneQuality
int32 next_r_laneWidthMarking

#0x76B highway road info
int32 highwayConstructionArea
int32 highwayRoadType
int32 highwayHighwayExitRight
int32 highwayHighwayExitLeft
float64   highwayProbabilityLeftLane
float64   highwayProbabilityRightLane
float64   highwayDriving_peed_left_lane
float64   highwayDriving_peed_right_lane
int32 highwayprotocol_version





================================================================================
MSG: std_msgs/Header
# Standard metadata for higher-level stamped data types.
# This is generally used to communicate timestamped data 
# in a particular coordinate frame.
# 
# sequence ID: consecutively increasing ID 
uint32 seq
#Two-integer timestamp that is expressed as:
# * stamp.sec: seconds (stamp_secs) since epoch (in Python the variable is called 'secs')
# * stamp.nsec: nanoseconds since stamp_secs (in Python the variable is called 'nsecs')
# time-handling sugar is provided by the client library
time stamp
#Frame this data is associated with
# 0: no frame
# 1: global frame
string frame_id

================================================================================
MSG: vehicle_msgs/FrameStamp
#MSG FrameStamp
Header header
float64 time
float64  lat
float64  lng
float64  height
float64[3] position
float64[3] orientation
float64[3] linearSpeed
float64[3] angularSpeed 
"""
  __slots__ = ['header','messageID','localStamp','globalStamp','l_numoflaneline','l_lanelineid','l_lanepositon','l_lanecurvature','l_lanecurvaturederivative','l_lane_type','l_heading_angle','l_lane_mark_color','l_laneQuality','l_laneWidthMarking','l_laneViewRangStart','l_laneViewRangEnd','l_laneCrossing','l_lanePRED_DIST_BASED_EXTRAPOLATION','l_lanePRED_OTHER_SIDE','l_lanePRED_OVERRIDE','l_lanePRED_OCCLUDED_LM_EXTRAPOLATION','l_lanePRED_HEADWAY_ORIENTED','l_lanePRED_SOURCE_DIVERGING_LANES','l_lanePRED_SOURCE_GUARDRAIL_SHADOW','l_lanePRED_SOURCE_HWE_SPAIN','l_lanePRED_SOURCE_STD','l_lanePRED_SOURCE_VRTL_MERGE','l_laneTCL','r_numoflaneline','r_lanelineid','r_lanepositon','r_lanecurvature','r_lanecurvaturederivative','r_lane_type','r_heading_angle','r_lane_mark_color','r_laneQuality','r_laneWidthMarking','r_laneViewRangStart','r_laneViewRangEnd','r_laneCrossing','r_lanePRED_DIST_BASED_EXTRAPOLATION','r_lanePRED_OTHER_SIDE','r_lanePRED_OVERRIDE','r_lanePRED_OCCLUDED_LM_EXTRAPOLATION','r_lanePRED_HEADWAY_ORIENTED','r_lanePRED_SOURCE_DIVERGING_LANES','r_lanePRED_SOURCE_GUARDRAIL_SHADOW','r_lanePRED_SOURCE_HWE_SPAIN','r_lanePRED_SOURCE_STD','r_lanePRED_SOURCE_VRTL_MERGE','r_laneTCL','next_l_laneViewRangStart','next_l_laneViewRangEnd','next_l_numoflaneline','next_l_lanelineid','next_l_lanepositon','next_l_lanecurvature','next_l_lanecurvaturederivative','next_l_lane_type','next_l_heading_angle','next_l_lane_mark_color','next_l_laneQuality','next_l_laneWidthMarking','next_r_laneViewRangStart','next_r_laneViewRangEnd','next_r_numoflaneline','next_r_lanelineid','next_r_lanepositon','next_r_lanecurvature','next_r_lanecurvaturederivative','next_r_lane_type','next_r_heading_angle','next_r_lane_mark_color','next_r_laneQuality','next_r_laneWidthMarking','highwayConstructionArea','highwayRoadType','highwayHighwayExitRight','highwayHighwayExitLeft','highwayProbabilityLeftLane','highwayProbabilityRightLane','highwayDriving_peed_left_lane','highwayDriving_peed_right_lane','highwayprotocol_version']
  _slot_types = ['std_msgs/Header','int32','vehicle_msgs/FrameStamp','vehicle_msgs/FrameStamp','int32','int32','float64','float64','float64','int32','float64','int32','int32','int32','int32','int32','int32','int32','int32','int32','int32','int32','int32','int32','int32','int32','int32','int32','int32','int32','float64','float64','float64','int32','float64','int32','int32','int32','int32','int32','int32','int32','int32','int32','int32','int32','int32','int32','int32','int32','int32','int32','int32','int32','int32','int32','float64','float64','float64','int32','float64','int32','int32','int32','int32','int32','int32','int32','float64','float64','float64','int32','float64','int32','int32','int32','int32','int32','int32','int32','float64','float64','float64','float64','int32']

  def __init__(self, *args, **kwds):
    """
    Constructor. Any message fields that are implicitly/explicitly
    set to None will be assigned a default value. The recommend
    use is keyword arguments as this is more robust to future message
    changes.  You cannot mix in-order arguments and keyword arguments.

    The available fields are:
       header,messageID,localStamp,globalStamp,l_numoflaneline,l_lanelineid,l_lanepositon,l_lanecurvature,l_lanecurvaturederivative,l_lane_type,l_heading_angle,l_lane_mark_color,l_laneQuality,l_laneWidthMarking,l_laneViewRangStart,l_laneViewRangEnd,l_laneCrossing,l_lanePRED_DIST_BASED_EXTRAPOLATION,l_lanePRED_OTHER_SIDE,l_lanePRED_OVERRIDE,l_lanePRED_OCCLUDED_LM_EXTRAPOLATION,l_lanePRED_HEADWAY_ORIENTED,l_lanePRED_SOURCE_DIVERGING_LANES,l_lanePRED_SOURCE_GUARDRAIL_SHADOW,l_lanePRED_SOURCE_HWE_SPAIN,l_lanePRED_SOURCE_STD,l_lanePRED_SOURCE_VRTL_MERGE,l_laneTCL,r_numoflaneline,r_lanelineid,r_lanepositon,r_lanecurvature,r_lanecurvaturederivative,r_lane_type,r_heading_angle,r_lane_mark_color,r_laneQuality,r_laneWidthMarking,r_laneViewRangStart,r_laneViewRangEnd,r_laneCrossing,r_lanePRED_DIST_BASED_EXTRAPOLATION,r_lanePRED_OTHER_SIDE,r_lanePRED_OVERRIDE,r_lanePRED_OCCLUDED_LM_EXTRAPOLATION,r_lanePRED_HEADWAY_ORIENTED,r_lanePRED_SOURCE_DIVERGING_LANES,r_lanePRED_SOURCE_GUARDRAIL_SHADOW,r_lanePRED_SOURCE_HWE_SPAIN,r_lanePRED_SOURCE_STD,r_lanePRED_SOURCE_VRTL_MERGE,r_laneTCL,next_l_laneViewRangStart,next_l_laneViewRangEnd,next_l_numoflaneline,next_l_lanelineid,next_l_lanepositon,next_l_lanecurvature,next_l_lanecurvaturederivative,next_l_lane_type,next_l_heading_angle,next_l_lane_mark_color,next_l_laneQuality,next_l_laneWidthMarking,next_r_laneViewRangStart,next_r_laneViewRangEnd,next_r_numoflaneline,next_r_lanelineid,next_r_lanepositon,next_r_lanecurvature,next_r_lanecurvaturederivative,next_r_lane_type,next_r_heading_angle,next_r_lane_mark_color,next_r_laneQuality,next_r_laneWidthMarking,highwayConstructionArea,highwayRoadType,highwayHighwayExitRight,highwayHighwayExitLeft,highwayProbabilityLeftLane,highwayProbabilityRightLane,highwayDriving_peed_left_lane,highwayDriving_peed_right_lane,highwayprotocol_version

    :param args: complete set of field values, in .msg order
    :param kwds: use keyword arguments corresponding to message field names
    to set specific fields.
    """
    if args or kwds:
      super(Camera_Lane, self).__init__(*args, **kwds)
      #message fields cannot be None, assign default values for those that are
      if self.header is None:
        self.header = std_msgs.msg.Header()
      if self.messageID is None:
        self.messageID = 0
      if self.localStamp is None:
        self.localStamp = vehicle_msgs.msg.FrameStamp()
      if self.globalStamp is None:
        self.globalStamp = vehicle_msgs.msg.FrameStamp()
      if self.l_numoflaneline is None:
        self.l_numoflaneline = 0
      if self.l_lanelineid is None:
        self.l_lanelineid = 0
      if self.l_lanepositon is None:
        self.l_lanepositon = 0.
      if self.l_lanecurvature is None:
        self.l_lanecurvature = 0.
      if self.l_lanecurvaturederivative is None:
        self.l_lanecurvaturederivative = 0.
      if self.l_lane_type is None:
        self.l_lane_type = 0
      if self.l_heading_angle is None:
        self.l_heading_angle = 0.
      if self.l_lane_mark_color is None:
        self.l_lane_mark_color = 0
      if self.l_laneQuality is None:
        self.l_laneQuality = 0
      if self.l_laneWidthMarking is None:
        self.l_laneWidthMarking = 0
      if self.l_laneViewRangStart is None:
        self.l_laneViewRangStart = 0
      if self.l_laneViewRangEnd is None:
        self.l_laneViewRangEnd = 0
      if self.l_laneCrossing is None:
        self.l_laneCrossing = 0
      if self.l_lanePRED_DIST_BASED_EXTRAPOLATION is None:
        self.l_lanePRED_DIST_BASED_EXTRAPOLATION = 0
      if self.l_lanePRED_OTHER_SIDE is None:
        self.l_lanePRED_OTHER_SIDE = 0
      if self.l_lanePRED_OVERRIDE is None:
        self.l_lanePRED_OVERRIDE = 0
      if self.l_lanePRED_OCCLUDED_LM_EXTRAPOLATION is None:
        self.l_lanePRED_OCCLUDED_LM_EXTRAPOLATION = 0
      if self.l_lanePRED_HEADWAY_ORIENTED is None:
        self.l_lanePRED_HEADWAY_ORIENTED = 0
      if self.l_lanePRED_SOURCE_DIVERGING_LANES is None:
        self.l_lanePRED_SOURCE_DIVERGING_LANES = 0
      if self.l_lanePRED_SOURCE_GUARDRAIL_SHADOW is None:
        self.l_lanePRED_SOURCE_GUARDRAIL_SHADOW = 0
      if self.l_lanePRED_SOURCE_HWE_SPAIN is None:
        self.l_lanePRED_SOURCE_HWE_SPAIN = 0
      if self.l_lanePRED_SOURCE_STD is None:
        self.l_lanePRED_SOURCE_STD = 0
      if self.l_lanePRED_SOURCE_VRTL_MERGE is None:
        self.l_lanePRED_SOURCE_VRTL_MERGE = 0
      if self.l_laneTCL is None:
        self.l_laneTCL = 0
      if self.r_numoflaneline is None:
        self.r_numoflaneline = 0
      if self.r_lanelineid is None:
        self.r_lanelineid = 0
      if self.r_lanepositon is None:
        self.r_lanepositon = 0.
      if self.r_lanecurvature is None:
        self.r_lanecurvature = 0.
      if self.r_lanecurvaturederivative is None:
        self.r_lanecurvaturederivative = 0.
      if self.r_lane_type is None:
        self.r_lane_type = 0
      if self.r_heading_angle is None:
        self.r_heading_angle = 0.
      if self.r_lane_mark_color is None:
        self.r_lane_mark_color = 0
      if self.r_laneQuality is None:
        self.r_laneQuality = 0
      if self.r_laneWidthMarking is None:
        self.r_laneWidthMarking = 0
      if self.r_laneViewRangStart is None:
        self.r_laneViewRangStart = 0
      if self.r_laneViewRangEnd is None:
        self.r_laneViewRangEnd = 0
      if self.r_laneCrossing is None:
        self.r_laneCrossing = 0
      if self.r_lanePRED_DIST_BASED_EXTRAPOLATION is None:
        self.r_lanePRED_DIST_BASED_EXTRAPOLATION = 0
      if self.r_lanePRED_OTHER_SIDE is None:
        self.r_lanePRED_OTHER_SIDE = 0
      if self.r_lanePRED_OVERRIDE is None:
        self.r_lanePRED_OVERRIDE = 0
      if self.r_lanePRED_OCCLUDED_LM_EXTRAPOLATION is None:
        self.r_lanePRED_OCCLUDED_LM_EXTRAPOLATION = 0
      if self.r_lanePRED_HEADWAY_ORIENTED is None:
        self.r_lanePRED_HEADWAY_ORIENTED = 0
      if self.r_lanePRED_SOURCE_DIVERGING_LANES is None:
        self.r_lanePRED_SOURCE_DIVERGING_LANES = 0
      if self.r_lanePRED_SOURCE_GUARDRAIL_SHADOW is None:
        self.r_lanePRED_SOURCE_GUARDRAIL_SHADOW = 0
      if self.r_lanePRED_SOURCE_HWE_SPAIN is None:
        self.r_lanePRED_SOURCE_HWE_SPAIN = 0
      if self.r_lanePRED_SOURCE_STD is None:
        self.r_lanePRED_SOURCE_STD = 0
      if self.r_lanePRED_SOURCE_VRTL_MERGE is None:
        self.r_lanePRED_SOURCE_VRTL_MERGE = 0
      if self.r_laneTCL is None:
        self.r_laneTCL = 0
      if self.next_l_laneViewRangStart is None:
        self.next_l_laneViewRangStart = 0
      if self.next_l_laneViewRangEnd is None:
        self.next_l_laneViewRangEnd = 0
      if self.next_l_numoflaneline is None:
        self.next_l_numoflaneline = 0
      if self.next_l_lanelineid is None:
        self.next_l_lanelineid = 0
      if self.next_l_lanepositon is None:
        self.next_l_lanepositon = 0.
      if self.next_l_lanecurvature is None:
        self.next_l_lanecurvature = 0.
      if self.next_l_lanecurvaturederivative is None:
        self.next_l_lanecurvaturederivative = 0.
      if self.next_l_lane_type is None:
        self.next_l_lane_type = 0
      if self.next_l_heading_angle is None:
        self.next_l_heading_angle = 0.
      if self.next_l_lane_mark_color is None:
        self.next_l_lane_mark_color = 0
      if self.next_l_laneQuality is None:
        self.next_l_laneQuality = 0
      if self.next_l_laneWidthMarking is None:
        self.next_l_laneWidthMarking = 0
      if self.next_r_laneViewRangStart is None:
        self.next_r_laneViewRangStart = 0
      if self.next_r_laneViewRangEnd is None:
        self.next_r_laneViewRangEnd = 0
      if self.next_r_numoflaneline is None:
        self.next_r_numoflaneline = 0
      if self.next_r_lanelineid is None:
        self.next_r_lanelineid = 0
      if self.next_r_lanepositon is None:
        self.next_r_lanepositon = 0.
      if self.next_r_lanecurvature is None:
        self.next_r_lanecurvature = 0.
      if self.next_r_lanecurvaturederivative is None:
        self.next_r_lanecurvaturederivative = 0.
      if self.next_r_lane_type is None:
        self.next_r_lane_type = 0
      if self.next_r_heading_angle is None:
        self.next_r_heading_angle = 0.
      if self.next_r_lane_mark_color is None:
        self.next_r_lane_mark_color = 0
      if self.next_r_laneQuality is None:
        self.next_r_laneQuality = 0
      if self.next_r_laneWidthMarking is None:
        self.next_r_laneWidthMarking = 0
      if self.highwayConstructionArea is None:
        self.highwayConstructionArea = 0
      if self.highwayRoadType is None:
        self.highwayRoadType = 0
      if self.highwayHighwayExitRight is None:
        self.highwayHighwayExitRight = 0
      if self.highwayHighwayExitLeft is None:
        self.highwayHighwayExitLeft = 0
      if self.highwayProbabilityLeftLane is None:
        self.highwayProbabilityLeftLane = 0.
      if self.highwayProbabilityRightLane is None:
        self.highwayProbabilityRightLane = 0.
      if self.highwayDriving_peed_left_lane is None:
        self.highwayDriving_peed_left_lane = 0.
      if self.highwayDriving_peed_right_lane is None:
        self.highwayDriving_peed_right_lane = 0.
      if self.highwayprotocol_version is None:
        self.highwayprotocol_version = 0
    else:
      self.header = std_msgs.msg.Header()
      self.messageID = 0
      self.localStamp = vehicle_msgs.msg.FrameStamp()
      self.globalStamp = vehicle_msgs.msg.FrameStamp()
      self.l_numoflaneline = 0
      self.l_lanelineid = 0
      self.l_lanepositon = 0.
      self.l_lanecurvature = 0.
      self.l_lanecurvaturederivative = 0.
      self.l_lane_type = 0
      self.l_heading_angle = 0.
      self.l_lane_mark_color = 0
      self.l_laneQuality = 0
      self.l_laneWidthMarking = 0
      self.l_laneViewRangStart = 0
      self.l_laneViewRangEnd = 0
      self.l_laneCrossing = 0
      self.l_lanePRED_DIST_BASED_EXTRAPOLATION = 0
      self.l_lanePRED_OTHER_SIDE = 0
      self.l_lanePRED_OVERRIDE = 0
      self.l_lanePRED_OCCLUDED_LM_EXTRAPOLATION = 0
      self.l_lanePRED_HEADWAY_ORIENTED = 0
      self.l_lanePRED_SOURCE_DIVERGING_LANES = 0
      self.l_lanePRED_SOURCE_GUARDRAIL_SHADOW = 0
      self.l_lanePRED_SOURCE_HWE_SPAIN = 0
      self.l_lanePRED_SOURCE_STD = 0
      self.l_lanePRED_SOURCE_VRTL_MERGE = 0
      self.l_laneTCL = 0
      self.r_numoflaneline = 0
      self.r_lanelineid = 0
      self.r_lanepositon = 0.
      self.r_lanecurvature = 0.
      self.r_lanecurvaturederivative = 0.
      self.r_lane_type = 0
      self.r_heading_angle = 0.
      self.r_lane_mark_color = 0
      self.r_laneQuality = 0
      self.r_laneWidthMarking = 0
      self.r_laneViewRangStart = 0
      self.r_laneViewRangEnd = 0
      self.r_laneCrossing = 0
      self.r_lanePRED_DIST_BASED_EXTRAPOLATION = 0
      self.r_lanePRED_OTHER_SIDE = 0
      self.r_lanePRED_OVERRIDE = 0
      self.r_lanePRED_OCCLUDED_LM_EXTRAPOLATION = 0
      self.r_lanePRED_HEADWAY_ORIENTED = 0
      self.r_lanePRED_SOURCE_DIVERGING_LANES = 0
      self.r_lanePRED_SOURCE_GUARDRAIL_SHADOW = 0
      self.r_lanePRED_SOURCE_HWE_SPAIN = 0
      self.r_lanePRED_SOURCE_STD = 0
      self.r_lanePRED_SOURCE_VRTL_MERGE = 0
      self.r_laneTCL = 0
      self.next_l_laneViewRangStart = 0
      self.next_l_laneViewRangEnd = 0
      self.next_l_numoflaneline = 0
      self.next_l_lanelineid = 0
      self.next_l_lanepositon = 0.
      self.next_l_lanecurvature = 0.
      self.next_l_lanecurvaturederivative = 0.
      self.next_l_lane_type = 0
      self.next_l_heading_angle = 0.
      self.next_l_lane_mark_color = 0
      self.next_l_laneQuality = 0
      self.next_l_laneWidthMarking = 0
      self.next_r_laneViewRangStart = 0
      self.next_r_laneViewRangEnd = 0
      self.next_r_numoflaneline = 0
      self.next_r_lanelineid = 0
      self.next_r_lanepositon = 0.
      self.next_r_lanecurvature = 0.
      self.next_r_lanecurvaturederivative = 0.
      self.next_r_lane_type = 0
      self.next_r_heading_angle = 0.
      self.next_r_lane_mark_color = 0
      self.next_r_laneQuality = 0
      self.next_r_laneWidthMarking = 0
      self.highwayConstructionArea = 0
      self.highwayRoadType = 0
      self.highwayHighwayExitRight = 0
      self.highwayHighwayExitLeft = 0
      self.highwayProbabilityLeftLane = 0.
      self.highwayProbabilityRightLane = 0.
      self.highwayDriving_peed_left_lane = 0.
      self.highwayDriving_peed_right_lane = 0.
      self.highwayprotocol_version = 0

  def _get_types(self):
    """
    internal API method
    """
    return self._slot_types

  def serialize(self, buff):
    """
    serialize message into buffer
    :param buff: buffer, ``StringIO``
    """
    try:
      _x = self
      buff.write(_get_struct_3I().pack(_x.header.seq, _x.header.stamp.secs, _x.header.stamp.nsecs))
      _x = self.header.frame_id
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self
      buff.write(_get_struct_i3I().pack(_x.messageID, _x.localStamp.header.seq, _x.localStamp.header.stamp.secs, _x.localStamp.header.stamp.nsecs))
      _x = self.localStamp.header.frame_id
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self
      buff.write(_get_struct_4d().pack(_x.localStamp.time, _x.localStamp.lat, _x.localStamp.lng, _x.localStamp.height))
      buff.write(_get_struct_3d().pack(*self.localStamp.position))
      buff.write(_get_struct_3d().pack(*self.localStamp.orientation))
      buff.write(_get_struct_3d().pack(*self.localStamp.linearSpeed))
      buff.write(_get_struct_3d().pack(*self.localStamp.angularSpeed))
      _x = self
      buff.write(_get_struct_3I().pack(_x.globalStamp.header.seq, _x.globalStamp.header.stamp.secs, _x.globalStamp.header.stamp.nsecs))
      _x = self.globalStamp.header.frame_id
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self
      buff.write(_get_struct_4d().pack(_x.globalStamp.time, _x.globalStamp.lat, _x.globalStamp.lng, _x.globalStamp.height))
      buff.write(_get_struct_3d().pack(*self.globalStamp.position))
      buff.write(_get_struct_3d().pack(*self.globalStamp.orientation))
      buff.write(_get_struct_3d().pack(*self.globalStamp.linearSpeed))
      buff.write(_get_struct_3d().pack(*self.globalStamp.angularSpeed))
      _x = self
      buff.write(_get_struct_2i3did19i3did21i3did7i3did7i4di().pack(_x.l_numoflaneline, _x.l_lanelineid, _x.l_lanepositon, _x.l_lanecurvature, _x.l_lanecurvaturederivative, _x.l_lane_type, _x.l_heading_angle, _x.l_lane_mark_color, _x.l_laneQuality, _x.l_laneWidthMarking, _x.l_laneViewRangStart, _x.l_laneViewRangEnd, _x.l_laneCrossing, _x.l_lanePRED_DIST_BASED_EXTRAPOLATION, _x.l_lanePRED_OTHER_SIDE, _x.l_lanePRED_OVERRIDE, _x.l_lanePRED_OCCLUDED_LM_EXTRAPOLATION, _x.l_lanePRED_HEADWAY_ORIENTED, _x.l_lanePRED_SOURCE_DIVERGING_LANES, _x.l_lanePRED_SOURCE_GUARDRAIL_SHADOW, _x.l_lanePRED_SOURCE_HWE_SPAIN, _x.l_lanePRED_SOURCE_STD, _x.l_lanePRED_SOURCE_VRTL_MERGE, _x.l_laneTCL, _x.r_numoflaneline, _x.r_lanelineid, _x.r_lanepositon, _x.r_lanecurvature, _x.r_lanecurvaturederivative, _x.r_lane_type, _x.r_heading_angle, _x.r_lane_mark_color, _x.r_laneQuality, _x.r_laneWidthMarking, _x.r_laneViewRangStart, _x.r_laneViewRangEnd, _x.r_laneCrossing, _x.r_lanePRED_DIST_BASED_EXTRAPOLATION, _x.r_lanePRED_OTHER_SIDE, _x.r_lanePRED_OVERRIDE, _x.r_lanePRED_OCCLUDED_LM_EXTRAPOLATION, _x.r_lanePRED_HEADWAY_ORIENTED, _x.r_lanePRED_SOURCE_DIVERGING_LANES, _x.r_lanePRED_SOURCE_GUARDRAIL_SHADOW, _x.r_lanePRED_SOURCE_HWE_SPAIN, _x.r_lanePRED_SOURCE_STD, _x.r_lanePRED_SOURCE_VRTL_MERGE, _x.r_laneTCL, _x.next_l_laneViewRangStart, _x.next_l_laneViewRangEnd, _x.next_l_numoflaneline, _x.next_l_lanelineid, _x.next_l_lanepositon, _x.next_l_lanecurvature, _x.next_l_lanecurvaturederivative, _x.next_l_lane_type, _x.next_l_heading_angle, _x.next_l_lane_mark_color, _x.next_l_laneQuality, _x.next_l_laneWidthMarking, _x.next_r_laneViewRangStart, _x.next_r_laneViewRangEnd, _x.next_r_numoflaneline, _x.next_r_lanelineid, _x.next_r_lanepositon, _x.next_r_lanecurvature, _x.next_r_lanecurvaturederivative, _x.next_r_lane_type, _x.next_r_heading_angle, _x.next_r_lane_mark_color, _x.next_r_laneQuality, _x.next_r_laneWidthMarking, _x.highwayConstructionArea, _x.highwayRoadType, _x.highwayHighwayExitRight, _x.highwayHighwayExitLeft, _x.highwayProbabilityLeftLane, _x.highwayProbabilityRightLane, _x.highwayDriving_peed_left_lane, _x.highwayDriving_peed_right_lane, _x.highwayprotocol_version))
    except struct.error as se: self._check_types(struct.error("%s: '%s' when writing '%s'" % (type(se), str(se), str(locals().get('_x', self)))))
    except TypeError as te: self._check_types(ValueError("%s: '%s' when writing '%s'" % (type(te), str(te), str(locals().get('_x', self)))))

  def deserialize(self, str):
    """
    unpack serialized message in str into this message instance
    :param str: byte array of serialized message, ``str``
    """
    try:
      if self.header is None:
        self.header = std_msgs.msg.Header()
      if self.localStamp is None:
        self.localStamp = vehicle_msgs.msg.FrameStamp()
      if self.globalStamp is None:
        self.globalStamp = vehicle_msgs.msg.FrameStamp()
      end = 0
      _x = self
      start = end
      end += 12
      (_x.header.seq, _x.header.stamp.secs, _x.header.stamp.nsecs,) = _get_struct_3I().unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.header.frame_id = str[start:end].decode('utf-8')
      else:
        self.header.frame_id = str[start:end]
      _x = self
      start = end
      end += 16
      (_x.messageID, _x.localStamp.header.seq, _x.localStamp.header.stamp.secs, _x.localStamp.header.stamp.nsecs,) = _get_struct_i3I().unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.localStamp.header.frame_id = str[start:end].decode('utf-8')
      else:
        self.localStamp.header.frame_id = str[start:end]
      _x = self
      start = end
      end += 32
      (_x.localStamp.time, _x.localStamp.lat, _x.localStamp.lng, _x.localStamp.height,) = _get_struct_4d().unpack(str[start:end])
      start = end
      end += 24
      self.localStamp.position = _get_struct_3d().unpack(str[start:end])
      start = end
      end += 24
      self.localStamp.orientation = _get_struct_3d().unpack(str[start:end])
      start = end
      end += 24
      self.localStamp.linearSpeed = _get_struct_3d().unpack(str[start:end])
      start = end
      end += 24
      self.localStamp.angularSpeed = _get_struct_3d().unpack(str[start:end])
      _x = self
      start = end
      end += 12
      (_x.globalStamp.header.seq, _x.globalStamp.header.stamp.secs, _x.globalStamp.header.stamp.nsecs,) = _get_struct_3I().unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.globalStamp.header.frame_id = str[start:end].decode('utf-8')
      else:
        self.globalStamp.header.frame_id = str[start:end]
      _x = self
      start = end
      end += 32
      (_x.globalStamp.time, _x.globalStamp.lat, _x.globalStamp.lng, _x.globalStamp.height,) = _get_struct_4d().unpack(str[start:end])
      start = end
      end += 24
      self.globalStamp.position = _get_struct_3d().unpack(str[start:end])
      start = end
      end += 24
      self.globalStamp.orientation = _get_struct_3d().unpack(str[start:end])
      start = end
      end += 24
      self.globalStamp.linearSpeed = _get_struct_3d().unpack(str[start:end])
      start = end
      end += 24
      self.globalStamp.angularSpeed = _get_struct_3d().unpack(str[start:end])
      _x = self
      start = end
      end += 404
      (_x.l_numoflaneline, _x.l_lanelineid, _x.l_lanepositon, _x.l_lanecurvature, _x.l_lanecurvaturederivative, _x.l_lane_type, _x.l_heading_angle, _x.l_lane_mark_color, _x.l_laneQuality, _x.l_laneWidthMarking, _x.l_laneViewRangStart, _x.l_laneViewRangEnd, _x.l_laneCrossing, _x.l_lanePRED_DIST_BASED_EXTRAPOLATION, _x.l_lanePRED_OTHER_SIDE, _x.l_lanePRED_OVERRIDE, _x.l_lanePRED_OCCLUDED_LM_EXTRAPOLATION, _x.l_lanePRED_HEADWAY_ORIENTED, _x.l_lanePRED_SOURCE_DIVERGING_LANES, _x.l_lanePRED_SOURCE_GUARDRAIL_SHADOW, _x.l_lanePRED_SOURCE_HWE_SPAIN, _x.l_lanePRED_SOURCE_STD, _x.l_lanePRED_SOURCE_VRTL_MERGE, _x.l_laneTCL, _x.r_numoflaneline, _x.r_lanelineid, _x.r_lanepositon, _x.r_lanecurvature, _x.r_lanecurvaturederivative, _x.r_lane_type, _x.r_heading_angle, _x.r_lane_mark_color, _x.r_laneQuality, _x.r_laneWidthMarking, _x.r_laneViewRangStart, _x.r_laneViewRangEnd, _x.r_laneCrossing, _x.r_lanePRED_DIST_BASED_EXTRAPOLATION, _x.r_lanePRED_OTHER_SIDE, _x.r_lanePRED_OVERRIDE, _x.r_lanePRED_OCCLUDED_LM_EXTRAPOLATION, _x.r_lanePRED_HEADWAY_ORIENTED, _x.r_lanePRED_SOURCE_DIVERGING_LANES, _x.r_lanePRED_SOURCE_GUARDRAIL_SHADOW, _x.r_lanePRED_SOURCE_HWE_SPAIN, _x.r_lanePRED_SOURCE_STD, _x.r_lanePRED_SOURCE_VRTL_MERGE, _x.r_laneTCL, _x.next_l_laneViewRangStart, _x.next_l_laneViewRangEnd, _x.next_l_numoflaneline, _x.next_l_lanelineid, _x.next_l_lanepositon, _x.next_l_lanecurvature, _x.next_l_lanecurvaturederivative, _x.next_l_lane_type, _x.next_l_heading_angle, _x.next_l_lane_mark_color, _x.next_l_laneQuality, _x.next_l_laneWidthMarking, _x.next_r_laneViewRangStart, _x.next_r_laneViewRangEnd, _x.next_r_numoflaneline, _x.next_r_lanelineid, _x.next_r_lanepositon, _x.next_r_lanecurvature, _x.next_r_lanecurvaturederivative, _x.next_r_lane_type, _x.next_r_heading_angle, _x.next_r_lane_mark_color, _x.next_r_laneQuality, _x.next_r_laneWidthMarking, _x.highwayConstructionArea, _x.highwayRoadType, _x.highwayHighwayExitRight, _x.highwayHighwayExitLeft, _x.highwayProbabilityLeftLane, _x.highwayProbabilityRightLane, _x.highwayDriving_peed_left_lane, _x.highwayDriving_peed_right_lane, _x.highwayprotocol_version,) = _get_struct_2i3did19i3did21i3did7i3did7i4di().unpack(str[start:end])
      return self
    except struct.error as e:
      raise genpy.DeserializationError(e) #most likely buffer underfill


  def serialize_numpy(self, buff, numpy):
    """
    serialize message with numpy array types into buffer
    :param buff: buffer, ``StringIO``
    :param numpy: numpy python module
    """
    try:
      _x = self
      buff.write(_get_struct_3I().pack(_x.header.seq, _x.header.stamp.secs, _x.header.stamp.nsecs))
      _x = self.header.frame_id
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self
      buff.write(_get_struct_i3I().pack(_x.messageID, _x.localStamp.header.seq, _x.localStamp.header.stamp.secs, _x.localStamp.header.stamp.nsecs))
      _x = self.localStamp.header.frame_id
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self
      buff.write(_get_struct_4d().pack(_x.localStamp.time, _x.localStamp.lat, _x.localStamp.lng, _x.localStamp.height))
      buff.write(self.localStamp.position.tostring())
      buff.write(self.localStamp.orientation.tostring())
      buff.write(self.localStamp.linearSpeed.tostring())
      buff.write(self.localStamp.angularSpeed.tostring())
      _x = self
      buff.write(_get_struct_3I().pack(_x.globalStamp.header.seq, _x.globalStamp.header.stamp.secs, _x.globalStamp.header.stamp.nsecs))
      _x = self.globalStamp.header.frame_id
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self
      buff.write(_get_struct_4d().pack(_x.globalStamp.time, _x.globalStamp.lat, _x.globalStamp.lng, _x.globalStamp.height))
      buff.write(self.globalStamp.position.tostring())
      buff.write(self.globalStamp.orientation.tostring())
      buff.write(self.globalStamp.linearSpeed.tostring())
      buff.write(self.globalStamp.angularSpeed.tostring())
      _x = self
      buff.write(_get_struct_2i3did19i3did21i3did7i3did7i4di().pack(_x.l_numoflaneline, _x.l_lanelineid, _x.l_lanepositon, _x.l_lanecurvature, _x.l_lanecurvaturederivative, _x.l_lane_type, _x.l_heading_angle, _x.l_lane_mark_color, _x.l_laneQuality, _x.l_laneWidthMarking, _x.l_laneViewRangStart, _x.l_laneViewRangEnd, _x.l_laneCrossing, _x.l_lanePRED_DIST_BASED_EXTRAPOLATION, _x.l_lanePRED_OTHER_SIDE, _x.l_lanePRED_OVERRIDE, _x.l_lanePRED_OCCLUDED_LM_EXTRAPOLATION, _x.l_lanePRED_HEADWAY_ORIENTED, _x.l_lanePRED_SOURCE_DIVERGING_LANES, _x.l_lanePRED_SOURCE_GUARDRAIL_SHADOW, _x.l_lanePRED_SOURCE_HWE_SPAIN, _x.l_lanePRED_SOURCE_STD, _x.l_lanePRED_SOURCE_VRTL_MERGE, _x.l_laneTCL, _x.r_numoflaneline, _x.r_lanelineid, _x.r_lanepositon, _x.r_lanecurvature, _x.r_lanecurvaturederivative, _x.r_lane_type, _x.r_heading_angle, _x.r_lane_mark_color, _x.r_laneQuality, _x.r_laneWidthMarking, _x.r_laneViewRangStart, _x.r_laneViewRangEnd, _x.r_laneCrossing, _x.r_lanePRED_DIST_BASED_EXTRAPOLATION, _x.r_lanePRED_OTHER_SIDE, _x.r_lanePRED_OVERRIDE, _x.r_lanePRED_OCCLUDED_LM_EXTRAPOLATION, _x.r_lanePRED_HEADWAY_ORIENTED, _x.r_lanePRED_SOURCE_DIVERGING_LANES, _x.r_lanePRED_SOURCE_GUARDRAIL_SHADOW, _x.r_lanePRED_SOURCE_HWE_SPAIN, _x.r_lanePRED_SOURCE_STD, _x.r_lanePRED_SOURCE_VRTL_MERGE, _x.r_laneTCL, _x.next_l_laneViewRangStart, _x.next_l_laneViewRangEnd, _x.next_l_numoflaneline, _x.next_l_lanelineid, _x.next_l_lanepositon, _x.next_l_lanecurvature, _x.next_l_lanecurvaturederivative, _x.next_l_lane_type, _x.next_l_heading_angle, _x.next_l_lane_mark_color, _x.next_l_laneQuality, _x.next_l_laneWidthMarking, _x.next_r_laneViewRangStart, _x.next_r_laneViewRangEnd, _x.next_r_numoflaneline, _x.next_r_lanelineid, _x.next_r_lanepositon, _x.next_r_lanecurvature, _x.next_r_lanecurvaturederivative, _x.next_r_lane_type, _x.next_r_heading_angle, _x.next_r_lane_mark_color, _x.next_r_laneQuality, _x.next_r_laneWidthMarking, _x.highwayConstructionArea, _x.highwayRoadType, _x.highwayHighwayExitRight, _x.highwayHighwayExitLeft, _x.highwayProbabilityLeftLane, _x.highwayProbabilityRightLane, _x.highwayDriving_peed_left_lane, _x.highwayDriving_peed_right_lane, _x.highwayprotocol_version))
    except struct.error as se: self._check_types(struct.error("%s: '%s' when writing '%s'" % (type(se), str(se), str(locals().get('_x', self)))))
    except TypeError as te: self._check_types(ValueError("%s: '%s' when writing '%s'" % (type(te), str(te), str(locals().get('_x', self)))))

  def deserialize_numpy(self, str, numpy):
    """
    unpack serialized message in str into this message instance using numpy for array types
    :param str: byte array of serialized message, ``str``
    :param numpy: numpy python module
    """
    try:
      if self.header is None:
        self.header = std_msgs.msg.Header()
      if self.localStamp is None:
        self.localStamp = vehicle_msgs.msg.FrameStamp()
      if self.globalStamp is None:
        self.globalStamp = vehicle_msgs.msg.FrameStamp()
      end = 0
      _x = self
      start = end
      end += 12
      (_x.header.seq, _x.header.stamp.secs, _x.header.stamp.nsecs,) = _get_struct_3I().unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.header.frame_id = str[start:end].decode('utf-8')
      else:
        self.header.frame_id = str[start:end]
      _x = self
      start = end
      end += 16
      (_x.messageID, _x.localStamp.header.seq, _x.localStamp.header.stamp.secs, _x.localStamp.header.stamp.nsecs,) = _get_struct_i3I().unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.localStamp.header.frame_id = str[start:end].decode('utf-8')
      else:
        self.localStamp.header.frame_id = str[start:end]
      _x = self
      start = end
      end += 32
      (_x.localStamp.time, _x.localStamp.lat, _x.localStamp.lng, _x.localStamp.height,) = _get_struct_4d().unpack(str[start:end])
      start = end
      end += 24
      self.localStamp.position = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=3)
      start = end
      end += 24
      self.localStamp.orientation = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=3)
      start = end
      end += 24
      self.localStamp.linearSpeed = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=3)
      start = end
      end += 24
      self.localStamp.angularSpeed = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=3)
      _x = self
      start = end
      end += 12
      (_x.globalStamp.header.seq, _x.globalStamp.header.stamp.secs, _x.globalStamp.header.stamp.nsecs,) = _get_struct_3I().unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.globalStamp.header.frame_id = str[start:end].decode('utf-8')
      else:
        self.globalStamp.header.frame_id = str[start:end]
      _x = self
      start = end
      end += 32
      (_x.globalStamp.time, _x.globalStamp.lat, _x.globalStamp.lng, _x.globalStamp.height,) = _get_struct_4d().unpack(str[start:end])
      start = end
      end += 24
      self.globalStamp.position = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=3)
      start = end
      end += 24
      self.globalStamp.orientation = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=3)
      start = end
      end += 24
      self.globalStamp.linearSpeed = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=3)
      start = end
      end += 24
      self.globalStamp.angularSpeed = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=3)
      _x = self
      start = end
      end += 404
      (_x.l_numoflaneline, _x.l_lanelineid, _x.l_lanepositon, _x.l_lanecurvature, _x.l_lanecurvaturederivative, _x.l_lane_type, _x.l_heading_angle, _x.l_lane_mark_color, _x.l_laneQuality, _x.l_laneWidthMarking, _x.l_laneViewRangStart, _x.l_laneViewRangEnd, _x.l_laneCrossing, _x.l_lanePRED_DIST_BASED_EXTRAPOLATION, _x.l_lanePRED_OTHER_SIDE, _x.l_lanePRED_OVERRIDE, _x.l_lanePRED_OCCLUDED_LM_EXTRAPOLATION, _x.l_lanePRED_HEADWAY_ORIENTED, _x.l_lanePRED_SOURCE_DIVERGING_LANES, _x.l_lanePRED_SOURCE_GUARDRAIL_SHADOW, _x.l_lanePRED_SOURCE_HWE_SPAIN, _x.l_lanePRED_SOURCE_STD, _x.l_lanePRED_SOURCE_VRTL_MERGE, _x.l_laneTCL, _x.r_numoflaneline, _x.r_lanelineid, _x.r_lanepositon, _x.r_lanecurvature, _x.r_lanecurvaturederivative, _x.r_lane_type, _x.r_heading_angle, _x.r_lane_mark_color, _x.r_laneQuality, _x.r_laneWidthMarking, _x.r_laneViewRangStart, _x.r_laneViewRangEnd, _x.r_laneCrossing, _x.r_lanePRED_DIST_BASED_EXTRAPOLATION, _x.r_lanePRED_OTHER_SIDE, _x.r_lanePRED_OVERRIDE, _x.r_lanePRED_OCCLUDED_LM_EXTRAPOLATION, _x.r_lanePRED_HEADWAY_ORIENTED, _x.r_lanePRED_SOURCE_DIVERGING_LANES, _x.r_lanePRED_SOURCE_GUARDRAIL_SHADOW, _x.r_lanePRED_SOURCE_HWE_SPAIN, _x.r_lanePRED_SOURCE_STD, _x.r_lanePRED_SOURCE_VRTL_MERGE, _x.r_laneTCL, _x.next_l_laneViewRangStart, _x.next_l_laneViewRangEnd, _x.next_l_numoflaneline, _x.next_l_lanelineid, _x.next_l_lanepositon, _x.next_l_lanecurvature, _x.next_l_lanecurvaturederivative, _x.next_l_lane_type, _x.next_l_heading_angle, _x.next_l_lane_mark_color, _x.next_l_laneQuality, _x.next_l_laneWidthMarking, _x.next_r_laneViewRangStart, _x.next_r_laneViewRangEnd, _x.next_r_numoflaneline, _x.next_r_lanelineid, _x.next_r_lanepositon, _x.next_r_lanecurvature, _x.next_r_lanecurvaturederivative, _x.next_r_lane_type, _x.next_r_heading_angle, _x.next_r_lane_mark_color, _x.next_r_laneQuality, _x.next_r_laneWidthMarking, _x.highwayConstructionArea, _x.highwayRoadType, _x.highwayHighwayExitRight, _x.highwayHighwayExitLeft, _x.highwayProbabilityLeftLane, _x.highwayProbabilityRightLane, _x.highwayDriving_peed_left_lane, _x.highwayDriving_peed_right_lane, _x.highwayprotocol_version,) = _get_struct_2i3did19i3did21i3did7i3did7i4di().unpack(str[start:end])
      return self
    except struct.error as e:
      raise genpy.DeserializationError(e) #most likely buffer underfill

_struct_I = genpy.struct_I
def _get_struct_I():
    global _struct_I
    return _struct_I
_struct_4d = None
def _get_struct_4d():
    global _struct_4d
    if _struct_4d is None:
        _struct_4d = struct.Struct("<4d")
    return _struct_4d
_struct_3I = None
def _get_struct_3I():
    global _struct_3I
    if _struct_3I is None:
        _struct_3I = struct.Struct("<3I")
    return _struct_3I
_struct_2i3did19i3did21i3did7i3did7i4di = None
def _get_struct_2i3did19i3did21i3did7i3did7i4di():
    global _struct_2i3did19i3did21i3did7i3did7i4di
    if _struct_2i3did19i3did21i3did7i3did7i4di is None:
        _struct_2i3did19i3did21i3did7i3did7i4di = struct.Struct("<2i3did19i3did21i3did7i3did7i4di")
    return _struct_2i3did19i3did21i3did7i3did7i4di
_struct_i3I = None
def _get_struct_i3I():
    global _struct_i3I
    if _struct_i3I is None:
        _struct_i3I = struct.Struct("<i3I")
    return _struct_i3I
_struct_3d = None
def _get_struct_3d():
    global _struct_3d
    if _struct_3d is None:
        _struct_3d = struct.Struct("<3d")
    return _struct_3d
